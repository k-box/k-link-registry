package klinkregistry

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/go-chi/chi"
)

// KlinkModel is the JSON representation of a K-Link
type KlinkModel struct {
	ID          int64  `json:"-"`
	Identifier  string `json:"id"`
	ManagerID   int64  `json:"manager_id"`
	Name        string `json:"name"`
	Website     string `json:"website"`
	Description string `json:"description"`
	Active      bool   `json:"active"`
}

// handleListKlink provides an endpoint that returns a list of all
// klinks inside the database
func (s *Server) handleListKlinks() http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		var responses []KlinkModel

		klinks, err := s.store.ListKlinks()
		if s.store.IsNotFound(err) {
			jsonResponse(w, responses)
			return
		} else if err != nil {
			jsonResponse(w, API2ErrDatabase)
			return
		}

		// user := s.sessions.GetUser(req)

		for _, klink := range klinks {
			// // remove all klinks not owned by the registrant,
			// // if the registrant is an USER (not ADMIN or OWNER)
			// if user.Role == RoleUser && klink.ManagerID != user.ID {
			// 	continue
			// }

			responses = append(responses, KlinkModel(*klink))
		}
		jsonResponse(w, responses)
	}
}

// handleGetKlink provides an endpoint that returns a single registrant
// from the database
func (s *Server) handleGetKlink() http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		var response KlinkModel
		id := chi.URLParam(req, "id")

		application, err := s.store.GetKlinkByIdentifier(id)
		if s.store.IsNotFound(err) {
			jsonResponse(w, API2ErrNotFound)
			return
		} else if err != nil {
			fmt.Println(err)
			jsonResponse(w, API2ErrDatabase)
			return
		}

		user := s.sessions.GetUser(req)
		// do not show unowned applications if the registrant is an USER
		// (not ADMIN or OWNER)
		if user.Role == RoleUser && application.ManagerID != user.ID {
			jsonResponse(w, API2ErrUnauthorized)
			return
		}

		response = KlinkModel(*application)

		jsonResponse(w, response)
		return
	}
}

// handleCreateKlink provides and endpoint that allows creation of new
// applications.
func (s *Server) handleCreateKlink() http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		var request KlinkModel
		var response KlinkModel

		if err := json.NewDecoder(req.Body).Decode(&request); err != nil {
			jsonResponse(w, API2ErrInvalidJSON)
			return
		}

		u := s.sessions.GetUser(req)

		app := Klink(request)

		app.ID = 0 // ID will be autogenerated by the database
		app.Identifier = generateToken()

		// If user is in the user role, it is not possible to change application
		// ownership
		if u.Role != RoleAdmin {
			jsonResponse(w, API2ErrUserNotAdmin)
			return
		}
		app.ManagerID = u.ID

		if err := s.store.CreateKlink(&app); err != nil {
			jsonResponse(w, API2ErrDatabase)
			return
		}

		response = KlinkModel(app)

		jsonResponse(w, response)
	}
}

// handleUpdateKlink provides and endpoint that allows updating of
// attributes for applications
func (s *Server) handleUpdateKlink() http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		var response KlinkModel
		var request KlinkModel

		id := chi.URLParam(req, "id")

		app, err := s.store.GetKlinkByIdentifier(id)
		if s.store.IsNotFound(err) {
			jsonResponse(w, API2ErrNotFound)
			return
		} else if err != nil {
			jsonResponse(w, API2ErrDatabase)
			return
		}

		user := s.sessions.GetUser(req)

		// check if we have permission to edit this application
		if user.ID == app.ManagerID {
			// we must either be the owner of this application ..
		} else if user.Role == RoleOwner || user.Role == RoleAdmin {
			// .. or have a role of admin or owner.
		} else {
			// otherwise we can strop processing here
			jsonResponse(w, API2ErrInvalidCredentials)
			return
		}

		if err := json.NewDecoder(req.Body).Decode(&request); err != nil {
			jsonResponse(w, API2ErrInvalidJSON)
			return
		}

		// use the application as a base to apply our request to:
		// app.ID must stay the same.
		app.Active = request.Active
		app.Name = request.Name
		app.Website = request.Website
		app.Description = request.Description

		log.Println("Updating Klink", app)

		// allow change of owner, if user is admin or owner
		// if user.Role == RoleOwner || user.Role == RoleAdmin {
		// 	app.OwnerID = request.OwnerID
		// }

		if err := s.store.UpdateKlink(app); err != nil {
			jsonResponse(w, API2ErrDatabase)
			return
		}

		response = KlinkModel(*app)
		jsonResponse(w, response)
		return
	}
}

// handleDeleteKlink provides an endpoint that allows deletion of
// applications
func (s *Server) handleDeleteKlink() http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		id := chi.URLParam(req, "id")

		app, err := s.store.GetKlinkByIdentifier(id)
		if s.store.IsNotFound(err) {
			// deletion should succeed if entry does not exist
			jsonResponse(w, API2EmptyResponse{})
			return
		} else if err != nil {
			jsonResponse(w, API2ErrDatabase)
			return
		}

		user := s.sessions.GetUser(req)

		if user.ID == app.ManagerID {
			// registrants can remove their own klinks
		} else if user.Role == RoleOwner || user.Role == RoleAdmin {
			// an admin or owner role may remove everything
		} else {
			jsonResponse(w, API2ErrUnauthorized)
			return
		}

		if err := s.store.DeleteKlink(app.ID); err != nil {
			jsonResponse(w, API2ErrDatabase)
			return
		}

		jsonResponse(w, API2EmptyResponse{})
		return
	}
}
