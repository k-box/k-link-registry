package klinkregistry

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	"github.com/go-chi/chi"
)

// ApplicationModel is the JSON representation of an Application
type ApplicationModel struct {
	ID          int64    `json:"id"`
	OwnerID     int64    `json:"owner_id"`
	Name        string   `json:"name"`
	URL         string   `json:"app_domain"`
	Token       string   `json:"token"`
	Permissions []string `json:"permissions"`
	Active      bool     `json:"active"`
}

// handleListApplications provides an endpoint that returns a list of all
// applications inside the database
func (s *Server) handleListApplications() http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		var responses []ApplicationModel

		applications, err := s.store.ListApplications()
		if s.store.IsNotFound(err) {
			jsonResponse(w, responses)
			return
		} else if err != nil {
			jsonResponse(w, API2ErrDatabase)
			return
		}

		user := s.sessions.GetUser(req)

		for _, application := range applications {
			// remove all applications not owned by the registrant,
			// if the registrant is an USER (not ADMIN or OWNER)
			if user.Role == RoleUser && application.OwnerID != user.ID {
				continue
			}

			responses = append(responses, ApplicationModel(*application))
		}

		jsonResponse(w, responses)
	}
}

// handleGetApplication provides an endpoint that returns a single registrant
// from the database
func (s *Server) handleGetApplication() http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		var response ApplicationModel
		idString := chi.URLParam(req, "id")
		id, err := strconv.ParseInt(idString, 10, 64)
		if err != nil {
			jsonResponse(w, API2ErrInvalidURL)
			return
		}

		application, err := s.store.GetApplicationByID(id)
		if s.store.IsNotFound(err) {
			jsonResponse(w, API2ErrNotFound)
			return
		} else if err != nil {
			fmt.Println(err)
			jsonResponse(w, API2ErrDatabase)
			return
		}

		user := s.sessions.GetUser(req)
		// do not show unowned applications if the registrant is an USER
		// (not ADMIN or OWNER)
		if user.Role == RoleUser && application.OwnerID != user.ID {
			jsonResponse(w, API2ErrUnauthorized)
			return
		}

		response = ApplicationModel(*application)

		jsonResponse(w, response)
		return
	}
}

// handleCreateApplication provides and endpoint that allows creation of new
// applications.
func (s *Server) handleCreateApplication() http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		var request ApplicationModel
		var response ApplicationModel

		if err := json.NewDecoder(req.Body).Decode(&request); err != nil {
			jsonResponse(w, API2ErrInvalidJSON)
			return
		}

		u := s.sessions.GetUser(req)

		app := Application(request)

		app.ID = 0                  // ID will be autogenerated by the database
		app.Token = generateToken() // Token set by user will be ignored

		// If user is in the user role, it is not possible to change application
		// ownership
		if u.Role == RoleUser {
			app.OwnerID = u.ID
		}

		if err := s.store.CreateApplication(&app); err != nil {
			jsonResponse(w, API2ErrDatabase)
			return
		}

		response = ApplicationModel(app)

		jsonResponse(w, response)
	}
}

// handleUpdateApplication provides and endpoint that allows updating of
// attributes for applications
func (s *Server) handleUpdateApplication() http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		var response ApplicationModel
		var request ApplicationModel

		idString := chi.URLParam(req, "id")
		id, err := strconv.ParseInt(idString, 10, 64)
		if err != nil {
			jsonResponse(w, API2ErrInvalidURL)
			return
		}

		app, err := s.store.GetApplicationByID(id)
		if s.store.IsNotFound(err) {
			jsonResponse(w, API2ErrNotFound)
			return
		} else if err != nil {
			jsonResponse(w, API2ErrDatabase)
			return
		}

		user := s.sessions.GetUser(req)

		// check if we have permission to edit this application
		if user.ID == app.OwnerID {
			// we must either be the owner of this application ..
		} else if user.Role == RoleOwner || user.Role == RoleAdmin {
			// .. or have a role of admin or owner.
		} else {
			// otherwise we can strop processing here
			jsonResponse(w, API2ErrInvalidCredentials)
			return
		}

		if err := json.NewDecoder(req.Body).Decode(&request); err != nil {
			jsonResponse(w, API2ErrInvalidJSON)
			return
		}

		// use the application as a base to apply our request to:
		// app.ID must stay the same.
		app.Active = request.Active
		app.Name = request.Name
		app.Permissions = request.Permissions
		app.URL = request.URL

		// allow change of owner, if user is admin or owner
		if user.Role == RoleOwner || user.Role == RoleAdmin {
			app.OwnerID = request.OwnerID
		}

		// regenerate user token, if it is different
		if request.Token != app.Token {
			app.Token = generateToken()
		}

		if err := s.store.ReplaceApplication(app); err != nil {
			jsonResponse(w, API2ErrDatabase)
			return
		}

		response = ApplicationModel(*app)
		jsonResponse(w, response)
		return
	}
}

// handleDeleteApplication provides an endpoint that allows deletion of
// applications
func (s *Server) handleDeleteApplication() http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		idString := chi.URLParam(req, "id")
		id, err := strconv.ParseInt(idString, 10, 64)
		if err != nil {
			jsonResponse(w, API2ErrInvalidURL)
			return
		}

		app, err := s.store.GetApplicationByID(id)
		if s.store.IsNotFound(err) {
			// deletion should succeed if entry does not exist
			jsonResponse(w, API2EmptyResponse{})
			return
		} else if err != nil {
			jsonResponse(w, API2ErrDatabase)
			return
		}

		user := s.sessions.GetUser(req)

		if user.ID == app.OwnerID {
			// registrants can remove their own applications
		} else if user.Role == RoleOwner || user.Role == RoleAdmin {
			// an admin or owner role may remove everything
		} else {
			jsonResponse(w, API2ErrUnauthorized)
			return
		}

		if err := s.store.DeleteApplication(app.ID); err != nil {
			jsonResponse(w, API2ErrDatabase)
			return
		}

		jsonResponse(w, API2EmptyResponse{})
		return
	}
}
